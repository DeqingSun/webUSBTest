<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>test Detection Camera Example</title>
    <script src="utils.js" type="text/javascript"></script>
</head>

<body>
    <div id="parameterPanel" style="display:none">
        <div> valid block need to have change larger than
            <input type="range" min="1" max="10" value="2" step="0.1" class="slider" id="sliderMultiply" oninput="this.nextElementSibling.value = this.value">
            <output>2</output> times of the
            <input type="range" min="1" max="64" value="16" class="slider" id="sliderNtop" oninput="this.nextElementSibling.value = this.value">
            <output>16</output> th largest block </div>
        <input type="range" min="100" max="5000" value="400" class="slider" id="sliderTrigCool" oninput="this.nextElementSibling.value = this.value">
        <output>400</output> ms retrigger cooldown
        <div id="debugIndo">debug info</div>
        <div>
            <video id="videoInput" class="hidden">Your browser does not support the video tag.</video>
        </div>
    </div>
    <div style="width: 95vw;height: 85vh;max-height: 85vh;border:none"> <img src="" id="imgDisp" style="width: 100%;height: 100%;object-fit: contain;"></div>
    <div style="width: 100%;border:none;">
        <canvas id="canvasOutput" width="640" height="480" style="padding: 0;margin:auto;display: block;"></canvas>
    </div>
    <script type="text/javascript">
        let utils = new Utils('errorMessage');
        let video = document.getElementById('videoInput');
        let vc = null;
        var roiIndex = [48 + 2, 48 + 5]; //For Steve: this shows which block need to be tracked. The blocks are numbered horizontally.
        var triggerCount = [0, 0, 0]
        var triggerLimit = 4;
        var triggerValue = [false, false, false];
        var previousTriggerTimes = [new Date(), new Date(), new Date()];
        var triggerLessDisplay = true;
        var showingDebug = false;

        function startVideoProcessing() {
            let src = new cv.Mat(video.height, video.width, cv.CV_8UC4);
            let currentFrame = new cv.Mat(video.height, video.width, cv.CV_8UC3);
            let prevFrame = new cv.Mat(video.height, video.width, cv.CV_8UC3);
            let diffFrame = new cv.Mat(video.height, video.width, cv.CV_8UC3);
            let diffGray = new cv.Mat(video.height, video.width, cv.CV_8UC1);
            let integralSum = new cv.Mat();
            let displayMat = new cv.Mat(video.height, video.width, cv.CV_8UC3);
            let sectionPoints = [];
            let sectionDiff = [];
            let sectionMove = [];
            let displayMatCrop = new cv.Mat();
            //div image to 8*8
            var videoXstep = video.width / 8;
            var videoYstep = video.height / 8;
            for (var j = 0; j < 8; j++) {
                for (var i = 0; i < 8; i++) {
                    var index = j * 8 + i;
                    var startX = i * videoXstep;
                    var endX = (i + 1) * videoXstep - 1;
                    var startY = j * videoYstep;
                    var endY = (j + 1) * videoYstep - 1;
                    sectionPoints.push([new cv.Point(startX, startY), new cv.Point(endX, endY)]);
                    sectionDiff.push(0);
                }
            }
            let redColor = new cv.Scalar(255, 0, 0, 255);
            let yellowColor = new cv.Scalar(255, 255, 0, 255);
            let greenColor = new cv.Scalar(0, 255, 0, 255);
            let cap = new cv.VideoCapture(video);
            const FPS = 30;

            function getSumOfArea(integralResult, x1, y1, x2, y2) {
                var valBottomRight = integralResult.intAt(y2 + 1, x2 + 1);
                var valTopLeft = integralResult.intAt(y1 + 1, x1 + 1);
                var valTopRight = integralResult.intAt(y1, x2 + 1);
                var valBottomLeft = integralResult.intAt(y2 + 1, x1);
                return valBottomRight + valTopLeft - valTopRight - valBottomLeft;
            }

            function median(numbers) {
                const sorted = numbers.slice().sort((a, b) => a - b);
                const middle = Math.floor(sorted.length / 2);
                if (sorted.length % 2 === 0) {
                    return (sorted[middle - 1] + sorted[middle]) / 2;
                }
                return sorted[middle];
            }

            function getTopN(values, n) {
                const sorted = values.slice().sort((a, b) => a - b);
                return sorted[sorted.length - 1 - n];
            }

            function processVideo() {
                try {
                    let begin = Date.now();
                    // start processing.
                    cap.read(src);
                    cv.cvtColor(src, currentFrame, cv.COLOR_RGBA2RGB);
                    cv.flip(currentFrame, currentFrame, 1);
                    cv.absdiff(currentFrame, prevFrame, diffFrame)
                    currentFrame.copyTo(prevFrame);
                    cv.cvtColor(diffFrame, diffGray, cv.COLOR_RGB2GRAY);
                    cv.integral(diffGray, integralSum, cv.CV_32S);
                    if (integralSum.intAt(video.height, video.width) > 0) { //skip if identical img
                        //
                        //cv.cvtColor(diffGray, displayMat, cv.COLOR_GRAY2RGB);
                        currentFrame.copyTo(displayMat);
                        for (var i = 0; i < 64; i++) {
                            sectionCorners = sectionPoints[i];
                            sectionDiff[i] = getSumOfArea(integralSum, sectionCorners[0].x, sectionCorners[0].y, sectionCorners[1].x, sectionCorners[1].y);
                        }
                        var topNValue = document.getElementById("sliderNtop").value;
                        var topNMultiply = document.getElementById("sliderMultiply").value;
                        var topN = getTopN(sectionDiff, topNValue);
                        //console.log(sectionDiff,medianDiff)
                        for (var i = 0; i < 64; i++) {
                            sectionCorners = sectionPoints[i];
                            sectionMove[i] = (sectionDiff[i] > (topN * topNMultiply));
                            if (showingDebug || roiIndex.includes(i)) {
                                if (sectionMove[i]) {
                                    cv.rectangle(displayMat, sectionCorners[0], sectionCorners[1], greenColor, 1);
                                }
                                else {
                                    if (roiIndex.includes(i)) {
                                        cv.rectangle(displayMat, sectionCorners[0], sectionCorners[1], yellowColor, 2);
                                    }
                                    else {
                                        cv.rectangle(displayMat, sectionCorners[0], sectionCorners[1], redColor, 1);
                                    }
                                }
                            }
                        }
                        //do tracking
                        {
                            for (var i = 0; i < roiIndex.length; i++) {
                                var index = roiIndex[i];
                                if (sectionMove[index]) {
                                    triggerCount[i]++;
                                    if (triggerCount[i] > triggerLimit) {
                                        triggerCount[i] = triggerLimit;
                                    }
                                }
                                else {
                                    triggerCount[i] -= 2;
                                    if (triggerCount[i] < 0) {
                                        triggerCount[i] = 0;
                                    }
                                }
                                if (triggerValue[i]) {
                                    if (triggerCount[i] == 0) {
                                        triggerValue[i] = false;
                                        console.log("Area " + i + " released")
                                    }
                                }
                                else {
                                    if (triggerCount[i] >= triggerLimit) {
                                        triggerValue[i] = true;
                                        var previousTriggerTime = previousTriggerTimes[i];
                                        var triggerTime = new Date();
                                        var diff = triggerTime - previousTriggerTime;
                                        previousTriggerTimes[i] = triggerTime;
                                        console.log("Area " + i + " pressed. diff: " + diff);
                                        var thresholdDiff = document.getElementById("sliderTrigCool").value;
                                        if (diff >= thresholdDiff) {
                                            incImageIndex(i);
                                        }
                                    }
                                }
                            }
                        }
                        //currentFrame.copyTo(dst);
                        if (triggerLessDisplay) {
                            var displayHeight = displayMat.rows / 8 * 3;
                            let rect = new cv.Rect(0, displayMat.rows - displayHeight, displayMat.cols, displayHeight);
                            displayMatCrop = displayMat.roi(rect);
                            cv.imshow('canvasOutput', displayMatCrop);
                        }
                        else {
                            cv.imshow('canvasOutput', displayMat);
                        }
                        //show debug info
                        {
                            const sorted = sectionDiff.slice().sort((a, b) => a - b);
                            document.getElementById("debugIndo").innerHTML = "min:" + sorted[0] + " max:" + sorted.at(-1) + " median:" + sorted[sorted.length / 2] + " big" + topNValue + "th:" + topN;
                        }
                        // schedule the next one.
                    }
                    let delay = 1000 / FPS - (Date.now() - begin);
                    setTimeout(processVideo, delay);
                }
                catch (err) {
                    console.log(err);
                }
            };
            // schedule the first one.
            setTimeout(processVideo, 0);
        }
        utils.loadOpenCv(() => {
            //console.log(cv.getBuildInformation());
            utils.startCamera('qvga', onVideoStarted, 'videoInput');
            prepareImgs();
            document.addEventListener("keydown", e => {
                if (e.key == 'd' || e.key == 'D') {
                    var debugDiv = document.getElementById("parameterPanel");
                    if (debugDiv.style.display == "none") {
                        debugDiv.style.display = "";
                        showingDebug = true;
                    }
                    else {
                        debugDiv.style.display = "none";
                        showingDebug = false;
                    }
                }
            })
        });

        function onVideoStarted() {
            height = video.videoHeight;
            width = video.videoWidth;
            video.setAttribute('width', width);
            video.setAttribute('height', height);
            vc = new cv.VideoCapture(video);
            startVideoProcessing();
        }
        //image switch code
        var rImagesPath = []
        var pImagesPath = []
        var allImgPath = [rImagesPath, pImagesPath];
        var artistIndex = 0;
        var artistImageIndex = 0;

        function prepareImgs() {
            for (var i = 0; i < 10; i++) {
                rImagesPath[i] = "r/" + i + ".jpg";
            }
            for (var i = 0; i < 10; i++) {
                pImagesPath[i] = "p/" + i + ".jpg";
            }
            updateImgs();
        }

        function incImageIndex(i) { //For Steve: this is how the code reacts to the swipe events
            if (i == 0) {
                artistIndex++;
                if (artistIndex >= allImgPath.length) {
                    artistIndex = 0;
                }
                artistImageIndex = 0;
            }
            if (i == 1) {
                artistImageIndex++;
                if (artistImageIndex >= allImgPath[artistIndex].length) {
                    artistImageIndex = 0;
                }
            }
            updateImgs();
        }

        function updateImgs() {
            document.getElementById("imgDisp").src = allImgPath[artistIndex][artistImageIndex];
        }
    </script>
</body>

</html>